１Ｍフラッシュライブラリの使用方法について（第7.6版）
					2000.4.7 任天堂開発３部 渡辺
========================================================================
このドキュメントは以下の章から構成されています。

（１）１Ｍフラッシュとは
（２）１Ｍフラッシュライブラリについて
（３）１Ｍフラッシュサンプルプログラムの説明
（４）１Ｍフラッシュ使用時の注意
（５）１Ｍフラッシュのスペックについて
（６）１Ｍフラッシュの複数使用について
（７）変更履歴

========================================================================
（１）１Ｍフラッシュとは
１Ｍフラッシュとは Nintendo64 のバックアップメモリとして用意された１Ｍビッ
トのフラッシュロムメモリのことです。
１ＭフラッシュはSRAMと同様にPIデバイスとしてアクセスされます。SRAMとの違
いは以下の点です。

・書き込み方法の違い
１ＭフラッシュはフラッシュROMの特性として、データの書き込み前にデータの
消去を行う必要があります。データの消去はセクタ(16Kbyte)単位で行います。
データ消去後、一旦フラッシュROM内部に存在する128バイトの書き込みバッファ
にデータを転送し、そのバッファからフラッシュROMにデータを転送して実際の
書き込みを行います。このためデータの書き込みはページ(128バイト)単位にな
ります。

・読み込み方法の違い
１Ｍフラッシュは使用するフラッシュのバージョンによりデータの読み込み方法
を変える必要があります。
この問題を避けるために、ライブラリに用意されているフラッシュリード関数を
使用してください。

・サイズの違い
サイズが１Ｍビットと大きくなっています。
なお、ページ0x3feと0x3ffは任天堂により将来のため予約されていますので、実験
以外では使用しないでください（ページ0x3feと0x3ffを含むセクタのイレースは問
題ありません）。

・速度の違い
１ＭフラッシュのPIデバイスとしての速度パラメータ（PIバスへのアクセス速度）
はSRAMと同じ値になっています。しかし、実際には書き込み時・読み込み時共に
ページ単位の操作に伴う余分な処理が発生してしまいます。このため特にデータ
書き込み時の速度はかなり遅くなってしまいます。

========================================================================
（２）１Ｍフラッシュライブラリについて

１Ｍフラッシュを使用するために、現在以下の関数が用意されています。

------------------------------------------------------------------------
OSPiHandle *osFlashInit(void)

１Ｍフラッシュ使用のためのPiハンドラ初期化関数です。
１Ｍフラッシュを使用前に一度実行してください。
なお、現在のハードウェアと現在用意されている関数ではこの関数の返り値を使
用する必要はありません。

------------------------------------------------------------------------
void	osFlashReadStatus(u8 *flash_status)

１Ｍフラッシュのステータスを読むための関数です。
引数 flash_status にステータスを返します。
現在のハードウェアにおけるステータスの仕様は暫定的なものであり、今後変更
される可能性があります。
通常この関数を使用する必要はありません。

------------------------------------------------------------------------
void	osFlashReadId(u32 *flash_type, u32 *flash_maker)

１ＭフラッシュのＩＤを読むための関数です。
引数 flash_type は現在使用している１Ｍフラッシュの仕様を、flash_maker は
現在使用している１Ｍフラッシュの各メーカー番号とそのメーカーのバージョン
番号を返します。
現在のハードウェアにおけるＩＤの仕様は暫定的なものであり、今後変更される
可能性があります
通常この関数を使用する必要はありません。

------------------------------------------------------------------------
void	osFlashClearStatus(void)

１Ｍフラッシュのステータスをクリアするための関数です。
通常この関数を使用する必要はありません。

------------------------------------------------------------------------
s32	osFlashAllErase(void)

１Ｍフラッシュの全領域のデータを消去する関数です。
返り値として、消去が成功した場合には0が、失敗した場合には-1が返ります。
全領域が同時に消去されるため、全領域を消去する場合にはosFlashSectorErase 
の実行を繰り返すよりも高速にデータの消去が可能です。
osFlashAllEraseの内部ではタイマー待ちが行われています。タイマー管理はVI
マネージャにより行われているため、この関数を使用する前に
osCreateViManager によりViマネージャを起動しておく必要があります。
全領域のデータ消去には数msecから数百msecの時間がかかります。

------------------------------------------------------------------------
void	osFlashAllEraseThrough(void)

１Ｍフラッシュの全領域のデータを消去する関数です。
osFlashAllEraseとの違いはosFlashAllEraseThrough内部では消去終了のステー
タスチェックを行っていない点です。
osFlashAllEraseの実行は即座に行われますが、実際のデータ消去には数msecか
ら数百msecの時間がかかります。データの消去が終了したかどうかは
osFlashCheckEraseEndを実行して判定します。
注意する必要があるのは、osFlashAllEraseThroughとosFlashCheckEraseEndとの
間に他のosFlash関数を実行してはいけないという点です。これは、
osFlashCheckEraseEnd実行前に他のosFlash関数を実行することで、フラッシュ
のステートが変わってしまう可能性があるためです。

------------------------------------------------------------------------
s32	osFlashSectorErase(u32 page_num)

１Ｍフラッシュの特定のセクタのデータを消去する関数です。
引数としてページ番号を指定し、指定されたページ番号を含むセクタが消去され
ます。
１セクタの大きさは128ページ(16Kbytes)で、0-0x7f,0x80-0xff,0x100-0x17f,…
の各ページがそれぞれ１セクタとなります。
返り値として、消去が成功した場合には0が、失敗した場合には-1が返ります。
osFlashSectorEraseの内部ではタイマー待ちが行われています。タイマー管理は
VIマネージャにより行われているため、この関数を使用する前に
osCreateViManagerによりViマネージャを起動しておく必要があります。
１セクタのデータ消去には数msecから数百msecの時間がかかります。

------------------------------------------------------------------------
void	osFlashSectorEraseThrough(u32 page_num)

１Ｍフラッシュの特定のセクタのデータを消去する関数です。
引数としてページ番号を指定し、指定されたページ番号を含むセクタが消去され
ます。
１セクタの大きさは128ページ(16Kbytes)で、0-0x7f,0x80-0xff,0x100-0x17f,…
の各ページがそれぞれ１セクタとなります。
osFlashSectorEraseとの違いはosFlashSectorEraseThrough内部では消去終了の
ステータスチェックを行っていない点です。
osFlashSectorEraseの実行は即座に行われますが、実際のデータ消去には数msec
から数百msecの時間がかかります。データの消去が終了したかどうかは
osFlashCheckEraseEndを実行して判定します。
注意する必要があるのは、osFlashSectorEraseThroughとosFlashCheckEraseEnd
との間に他のosFlash関数を実行してはいけないという点です。これは、
osFlashCheckEraseEnd実行前に他のosFlash関数を実行することで、フラッシュ
のステートが変わってしまう可能性があるためです。

------------------------------------------------------------------------
s32     osFlashCheckEraseEnd(void);

１ＭフラッシュへのosFlashAllEraseThrough及びosFlashSectorEraseThroughの
実行が終了したかどうかの判定を行う関数です。
この関数の返り値として、消去が実行中の場合には FLASH_STATUS_ERASE_BUSY 
が、消去が成功した場合には FLASH_STATUS_ERASE_OK が、消去が失敗した場合
には FLASH_STATUS_ERASE_ERRORがそれぞれ返ります。

------------------------------------------------------------------------
s32	osFlashWriteBuffer(OSIoMesg *mb, s32 priority, 
			void *dramAddr, OSMesgQueue *mq)

１Ｍフラッシュの書き込みバッファへDMAでデータの書き込みを行う関数です。
引数はそれぞれ、メッセージリクエストブロック(*mb)、リクエスト優先順位
(priority)、バッファアドレス(*read_buf)、DMA終了受取りメッセージキュー
(*mq)です。
返り値はPIマネージャが実行されていない場合には-1を、そうでない場合には
osSendMesg か osJamMesg のどちらかのステータスを返します。

使用方法は基本的に
s32	osPiStartDma(OSIoMesg *mb, s32 priority, s32 direction, u32 devAddr, 
        	        void *dramAddr, u32 size, OSMesgQueue *mq)
に準拠した形になっています。osPiStartDmaとの違いは 以下の点です。

・引数 direction がない（書き込み専用のため）。
・引数 devAddr がない（１Ｍフラッシュのバッファのアドレスは固定のため）。
・引数 size がない（読み込みサイズが1ページ＝128バイトに決っているため）。

１Ｍフラッシュで特定のページに対してデータの書き込みを行うためには、以下
の手順を取ります。
	(1)データの消去
	(2)RDRAMから１Ｍフラッシュ内の書き込みバッファへのデータの転送
	(3)書き込みバッファから１Ｍフラッシュの各ページへのデータの転送
この関数は上記の(2)の動作を行うための関数です。

------------------------------------------------------------------------
s32	osFlashWriteArray(u32 page_num)

１Ｍフラッシュの書き込みバッファから１Ｍフラッシュの各ページにデータを書
き込む関数です。
引数としてページ番号を指定します。
返り値として、書き込みが成功した場合には0が、失敗した場合には-1が返りま
す。

１Ｍフラッシュで特定のページに対してデータの書き込みを行うためには、以下
の手順を取ります。
	(1)データの消去
	(2)RDRAMから１Ｍフラッシュ内の書き込みバッファへのデータの転送
	(3)書き込みバッファから１Ｍフラッシュの各ページへのデータの転送
この関数は上記の(3)の動作を行うための関数です。
なお、ページ0x3feと0x3ffは任天堂により予約されていますので、使用しないで
ください。
osFlashWriteArrayの内部ではタイマー待ちが行われています。タイマー管理は
VIマネージャにより行われているため、この関数を使用する前に
osCreateViManagerによりViマネージャを起動しておく必要があります。

------------------------------------------------------------------------
s32	osFlashReadArray(OSIoMesg *mb, s32 priority, u32 page_num,
			 void *dramAddr, u32 n_pages, OSMesgQueue *mq)

１Ｍフラッシュに書き込まれたデータを読むための関数です。
引数はそれぞれ、メッセージリクエストブロック(*mb)、リクエスト優先順位
(priority)、読み込み開始ページ番号(page_num)、読み込み先バッファアドレ
ス(*read_buf)、読み込みページ数(n_pages)、DMA終了受取りメッセージキュー
(*mq)となっています。
返り値はPIマネージャが実行されていない場合には-1を、そうでない場合には
osSendMesg か osJamMesg のどちらかのステータスを返します。

使用方法は基本的に
s32	osPiStartDma(OSIoMesg *mb, s32 priority, s32 direction, u32 devAddr, 
			void *dramAddr, u32 size, OSMesgQueue *mq)
に準拠した形になっています。osPiStartDmaとの違いは 以下の点です。

・引数 direction がない（読み込み専用のため）。
・引数 size の代りに読み込みページ数 n_pages がある。
・引数 devAddr の代りに読み込み開始ページ番号 page_num が引数になって
いる。

1回のDMAがページ 0x0-0xff, 0x100-0x1ff, 0x200-0x2ff, 0x300-0x3ff の各
32Kbyte単位に収まっていない場合、ライブラリ内部でDMAが複数回に分割されて
実行されます。

------------------------------------------------------------------------
void    osFlashChange(u32 flash_num);

複数の１Ｍフラッシュを使用する場合に、使用する１Ｍフラッシュのチップを切
り替えるための関数です。
引数flash_numは使用するフラッシュの番号を表します。番号は0から3まで指定
可能です。１Ｍフラッシュを１個のみ使用する場合は値として0を指定します。
２個の１Ｍフラッシュを使用する場合、１個目の１Ｍフラッシュを使用する際に
は osFlashChange(0) を ２個目の１Ｍフラッシュを使用する際には 
osFlashChange(1) をそれぞれ実行します。
使用する１Ｍフラッシュを切り替えた後は、１Ｍフラッシュを１個のみ使用する
場合と同様にそれぞれの１Ｍフラッシュが使用可能です。
なお、複数個の１Ｍフラッシュを使用する場合には、必ず同一IDのフラッシュを
使用してください。

複数の１Ｍフラッシュを切り替えて使用することで最大４Ｍビット（４個の１Ｍ
フラッシュを使用）まで記録領域を拡大することが可能です。

========================================================================
（３）１Ｍフラッシュサンプルプログラムの説明
１Ｍフラッシュライブラリの使用方法についてはサンプルプログラムflash_test
を参考にしてください。

flash_testの基本操作は以下の通りです。
	十字キー上下	：	コマンドの選択
	Ａボタン	：	コマンドの実行
	Ｃボタンユニット：	各パラメータの変更

以下は各コマンドの意味です
	FLASH CHANGE	:	使用するフラッシュの切り替えです。0から3
				まで指定可能です。

	READ ID		:	フラッシュのIDのリードです。

	READ STATUS	:	フラッシュのステータスのリードです。

	CLEAR STATUS	:	フラッシュのステータスのクリアです。

	ALL ERASE	:	フラッシュの全データを消去します。

	SECTOR ERASE	:	フラッシュの特定の１セクタを消去します。
				消去するセクタは PAGE NUMBER で指定した
				ページを含む１セクタです。

	READ ARRAY(DMA)	:	フラッシュの特定のページをDMAでリードし
				ます。
				リードするページはPAGE NUMBERで指定した
				ページからPAGE LENGTH分です。

	WRITE BUFFER	:	フラッシュのバッファへのライトです。

	WRITE ARRAY	:	フラッシュのバッファからフラッシュ各ペー
				ジへのライトです。
				リードするページは PAGE NUMBER で指定し
				たページです。

	FILL WRITE DATA	:	乱数によりPAGE NUMBER で指定したページの
	 (1 PAGE)		ための１ページ分の書き込みデータパターン
				を作成します。データの最後の4バイトには
				ページ番号が入ります。

	CLEAR ALL 	:	テストプログラムが持っている読み込みバッ
	 READ DATA		ファ内のデータを消去します。

	CLEAR ALL 	:	テストプログラムが持っている書き込みバッ
	 WRITE DATA		ファ内のデータを消去します。

	ALL ERASE &	:	フラッシュの全領域に対して消去・書き込み
	 FILL & WRITE		データ作成・書き込みを行います。

	ALL READ	:	フラッシュの全領域からデータを読み込みま
				す。データの読み込みは１ページリードで行
				われます。

	ALL COMPARE	:	テストプログラムが持っている読み込みバッ
	 			ファと書き込みバッファの全内容を比較しま
				す。

	REGION COMPARE	:	テストプログラムが持っている読み込みバッ
	 			ファと書き込みバッファの特定領域の内容を
				比較します。比較する領域はPAGE NUMBERで
				指定したページからPAGE LENGTH分です。

	ALL TEST	:	指定した回数分だけ ALL ERASE -> ALL FILL 
				-> ALL WRITE -> ALL COMPARE を実行します。

	PAGE LENGTH	:	ページ長を指定します。動作実験以外では原則
				1を指定してください。

	PAGE NUMBER	:	ページ番号を指定します。

========================================================================
（４）１Ｍフラッシュ使用時の注意
（４─１）書き換え可能回数について
１Ｍフラッシュの書き換え可能回数は、保証値で１０万回です。
これは各セクタに対する消去の保証回数が１０万回であるためです。
ゲームプレイ中に、書き換え回数がこの値を越えることがないように注意してく
ださい。
例えば毎秒同一ページにデータを書き込んだ場合、３０時間足らずで保証値を越
えてしまいます。
このような場合には、データの書き換え間隔を引き延ばしたり、同一ページに書
き込むのではなく、複数のページを順番に使用して一ページあたりの書き換え回
数を減らすようにしてください。
また、代替ページを用意したり、エラー訂正を行ったりするのも一つの方法です。

（４─２）書き込み時のエラー処理について
データ書き込み時にエラーが発生した場合には、イレース処理から再度書き込み
を繰り返してください。３回以上リトライしても書き込みエラーが発生した場合
には、TV画面にエラー表示を行い、ユーザに対してゲームの取り扱い説明書を見
るように促してください。また、取り扱い説明書にはエラーに対する対処を記載
してください。

（４─３）データの二重化について
フラッシュの容量にゆとりがある場合には、データ書き込み中に電源が落ちた場
合等に備えて書き込みデータを二重化することを推奨します。
同一のデータを別々のページに記録することで一方のデータが破壊されても他方
のデータを使用して一つ前の状態に復帰することが可能です。
なお、書き込み途中に処理が中断されたことによるエラーを検出するにはアプリ
ケーションプログラムが自身でデータの整合性をチェックする必要があります。

（４─３）予約ページについて
ページ番号 0x3fe, 0x3ff については任天堂の予約ページとなっており、ゲーム
中でのリード・ライトは行わないでください。ただし、ページ0x3fe,0x3ffに対
するイレース処理(osFlashAllErase、ページ番号0x380以降のページに対する
osFlashSectorErase)は実行しても問題ありません。

（４─４）コマンド実行中のコマンド発行について
１Mフラッシュへの各コマンド実行中にステータスリード(osFlashCheckEraseEnd
及びosFlashReadStatus)以外のコマンドを発行するとエラーが発生する場合があ
ります。
このような問題が起きるのは、osFlashSectorEraseThroughまたは
osFlashAllEraseThrough実行後にosFlashCheckEraseEndでデータの消去が終了し
たことを確認する前に他のosFlash関数を実行してしまうが、または複数のスレッ
ドから非同期にosFlash関数を実行した場合です。

（４─５）IDについて
現在使用されているIDは以下の通りです。
<flash_type>
0x11118001 : 1Mbitsタイプのフラッシュであることを表わします。

<flash_maker>
0x00c20000 : 初期タイプ(プロトタイプAバージョン)。使用するためには基板上
で改造が必要です。この仕様のものが実際のゲームで使用されることはありませ
ん。テストプログラムでは"PROTO A VERSION"と表示されます。
特定のコマンドの組合わせで不具合が発生する可能性があります。
実験以外では使用しないでください。

0x00c20001 : 初期タイプ(Aバージョン)。0x00c20000のタイプと同一仕様品です。
この仕様のものが実際のゲームで使用されることはありません。テストプログラ
ムでは"A VERSION"と表示されます。
特定のコマンドの組合わせで不具合が発生する可能性があります。
実験以外では使用しないでください。

0x00c2001e : 改良品(Cバージョン)。Aバージョンにあった不具合の一部が改善
され、基板上での改造が不要になったものです。実際のゲームで使用されるバー
ジョンです。テストプログラムでは"C VERSION"と表示されます。
改造済みのAバージョンとはフラッシュのイメージの出方が異なりますが、ライ
ブラリを使用してアクセスする場合には同等品と考えて問題ありません。B, Dバー
ジョンとはアドレスの解釈が異なっており、ライブラリ内部で処理を分岐して対
応しています。

0x00c2001d : 改良品(B, Dバージョン)。このIDのものには基板上で改造が必要
なもの(Bバージョン)と改造が不要なもの(Dバージョン)の２タイプが存在します。
テストプログラムではB, Dバージョン共に"B or D VERSION"と表示されます。
改造済みのBバージョンとDバージョンはフラッシュのイメージの出方が異なりま
すが、ライブラリを使用してアクセスする場合には同等品と考えて問題ありませ
ん。A,Cバージョンとはアドレスの解釈が異なり、ライブラリ内部で処理を分岐
して対応しています。本来正しいアドレスの解釈をしているのはこちらのバージョ
ンです。
現在存在しているDバージョンには若干の問題があり、改良が進められています。

上記のIDのフラッシュは全てマクロニクス製です。

0x003200f1 : 松下製フラッシュ。現在開発中のものです。製品でこのIDのもの
が使用されるかどうかは未定です。

その他	：   その他いくつかのフラッシュが試験的に作成されています。それ
らのフラッシュを使用した場合、テストプログラムでの表示は UNKOWN VERSION
となります。その場合ライブラリの動作は保証されません。

2000年4月4日段階で主に使用されている１ＭフラッシュはCバージョンです。
Bバージョン以前の１Ｍフラッシュについては使用しないでください。
Dバージョンは現在改良が進められており、Eバージョンとして今後リリースされ
る予定です。
また、A-Dバージョンのマクロニクス製フラッシュとは別に松下製フラッシュの
開発が進められています。

========================================================================
（５）１Ｍフラッシュのスペックについて
現在使用されているマクロニクス製１Ｍフラッシュのハードウェアスペックは以
下の通りです。

Sector Erase	 		typ:200ms	max:800ms
ALL Erase 			typ:200ms	max:800ms
Write Array  			typ:3ms		max:80ms
ALL Erase + 全page write	typ:3s		max:6s
書き換え保証回数		100000回

この仕様は今後変更される可能性があります。

実際には大部分のフラッシュはtypical値で示されている時間よりも高速に処理
が行われます（使用するフラッシュのメーカーやバージョンによっては上記の値
より二桁以上速い場合もあります）。
フラッシュは書き換えを繰り返すと次第に遅くなりますが、書き換え保証回数内
でありながら速度がmax値に達することは有りません。
ゲームプログラムではフラッシュの速度に大きなばらつきがあることを踏まえて、
上記max値以内のどのような速度のフラッシュであってもゲームが停止してしま
うような致命的な問題が発生しないように注意してください。

========================================================================
（６）１Ｍフラッシュの複数使用について
１Ｍフラッシュは複数個のチップを切り替えて使用することで最大４メガビット
（４個使用）まで記録領域を拡大することが可能です。
１Ｍフラッシュの切り替え方法については osFlashChange を参照してください。

========================================================================
（７）変更履歴
（７─１）第7.5版との違いについて
・32Kbyte境界を越えるDMAに対応するため、osFlashReadArrayの内部処理が変
更されました。
・osFlashAllEraseThrough・osFlashSectorEraseThrough・osFlashCheckEraseEnd
が追加されました。
・ドキュメント・サンプルが一部変更されました。

------------------------------------------------------------------------
（７─２）第7.41版との違いについて
・低優先度のスレッド動作のため、osFlashAllErase・osFlashSectorErase・
osFlashWriteArrayのそれぞれの内部処理にタイマー待ちが追加されました。

------------------------------------------------------------------------
（７─３）第7.4版との違いについて
・osFlashReadId内部でのキャッシュ処理に関する問題が修正されました。

------------------------------------------------------------------------
（７─４）第7.3版との違いについて
・現在開発中の松下製１Ｍフラッシュロムに対応するためのコードが追加され
ました。
・このドキュメントの記述が一部変更されました。

------------------------------------------------------------------------
（７─５）第7.2版との違いについて
・複数個の１Ｍフラッシュ使用のために関数 osFlashChange が追加されました。
・サンプルプログラムが一部変更され、通常動作の確認に不要な一部の機能がな
くなりました。また、osFlashChange 実行の機能が追加されました。
・IDに関する情報が更新されました。

------------------------------------------------------------------------
（７─６）第7.1版との違いについて
・PC用のREADMEファイル(READMEPC.txt)が追加されました。

------------------------------------------------------------------------
（７─７）第6版との違いについて
・サンプルが一部変更され、FILL WRITE DATA でのページ番号挿入位置がバッファ
の最初の4バイトから最後の4バイトに変更されました。

次に内部的な変更点です。
これらの変更点についてはゲームプログラマは特に気にする必要はありません。

・特定ロットでのコマンドコンビネーションの問題の回避のため 
osFlashReadArray 内部にダミーリードが追加されました。これに伴い、第6版で
の変更点である SetRead ID コマンド発行後の osFlashReadStatus は削除され
ました。

------------------------------------------------------------------------
（７─８）第5版との違いについて
第5版との変更点は内部的な変更点だけなので、ゲームプログラマは特に気にす
る必要はありません。

・特定ロットでのコマンドコンビネーションの問題の回避のため osFlashReadId 
内部で  SetRead ID コマンド発行後に osFlashReadStatus が実行されるように
変更されました。

------------------------------------------------------------------------
（７─９）第4版との違いについて
第4版とは以下の点が異なっています。

・osFlashBufferDma でのバッファに対するリード機能がなくなりなりました。
これに伴い関数名が osFlashWriteBuffer に変更され、引数から direction が
無くなりました。
・Cバージョンの１Ｍフラッシュで発生していた以下のコマンドコンビネーショ
ンの問題が改善されました。
  1.クリアステータス実行直後にリードIDを実行すると正しいIDが読めない。
  2.リードID実行直後にリードステータスを実行すると正しいステータスが読め
    ない。
なお、プロトタイプAバージョン及びAバージョンの各バージョンでは別のコマン
ドコンビネーションの問題が発生する可能性があります。
・Cバージョンのハードウェアの配布に伴い、プロトタイプAバージョンおよびA
バージョンで発生する不具合に対するライブラリの改訂がなくなりました。従来
プロトタイプAバージョンおよびAバージョンを使用してきた場合には、原則とし
てCバージョンのハードウェアに差し換えてください。
・サンプルが一部変更されました。
・ヘッダファイル flash.h にフラッシュのハードウェアバージョンに関する定
義（IDのflash_makerの定義）が追加されました。

次に内部的な変更点です。
これらの変更点についてはゲームプログラマは特に気にする必要はありません。

・コマンドコンビネーションの問題の回避のため osFlashReadStatus が内部で２
回 Read Status Register コマンドを発行するように変更されました。
・コマンドコンビネーションの問題の回避のため osFlashReadId 内部で  Set
Read ID コマンド発行前に osFlashReadStatus が実行されるように変更されま
した。

------------------------------------------------------------------------
（７─１０）第3版との違いについて
第3版とは以下の点が異なっています。

・ID の flash_makerが 0x00c20000 であるバージョンに対応しました。
・「（４─４）現在使用されているIDについて」が追加されました。

なお、前回のバージョンにあった以下の変更予定

・１Ｍフラッシュの仕様変更に伴い、標準仕様の１Ｍフラッシュの開始アドレス
が0x08000000から0x08020000に変更になります。変更されたライブラリ（第４版）
は仕様変更後の１Ｍフラッシュと共に２月第２週にリリースされる予定です。

はなくなりました。すなわち１Ｍフラッシュの開始アドレスは製品版においても
0x08000000からとなり、対応ライブラリのリリースもありません。バージョン的
には今回のライブラリが第４版となります。

次に内部的な変更点です。
これらの変更点についてはゲームプログラマは特に気にする必要はありません。

・ID解釈時に使用するバイト数が2バイトから4バイトに変更になりました。

------------------------------------------------------------------------
（７─１１）第2版との違いについて
第2版とは以下の点が異なっています。
	
・今後の混乱を避けるため、osFlashPageErase が osFlashSectorEraseに変更さ
れました。なお、第２版の osFlashPageErase でも実際の消去はSector単位で行
われています。
・osFlashWriteArray, osFlashSectorErase(旧osFlashPageErase),
osFlashAllEraseの各関数で、正常に動作が行われたにも関わらず、エラーが返っ
てくる不具合が修正されました。
・このドキュメントに「（４）１Ｍフラッシュ使用時の注意」が追加されました。
・このドキュメントに「（５）１Ｍフラッシュのスペックについて」が追加され
ました。
・サンプルが一部変更されました。

次に内部的な変更点です。
これらの変更点についてはゲームプログラマは特に気にする必要はありません。

・今後リリース予定の１Ｍフラッシュに対応するため、osFlashReadArrayで１Ｍ
フラッシュのIDによって読み込み動作が変るように変更されました。
IDの読み込みはosFlashInit実行時に行われます。
・osFlashWriteArray, osFlashSectorErase(旧osFlashPageErase),
FlashAllEraseの各関数内部で、コマンド実行後に osFlashClearStatus が実行
されるように変更されました。この変更は今後の１Ｍフラッシュの仕様変更に対
応するためのものです。

------------------------------------------------------------------------
（７─１２）第1版との違いについて
第1版とは以下の点が異なっています。

まず、重要な変更点についてです。

・＜重要＞osFlashReadArrayの仕様が変更になり、引数に新たに 「読み込みペー
ジ数(n_pages)」が追加されました。
・＜重要＞ページ0x3feと0x3ffが任天堂により予約され、ゲーム中での使用が原
則として禁止されました。

次にその他の変更点です。

・ページ0x1ffとページ0x3ffの後半64バイトで発生していたリードの不具合が解
消されました。
・サンプルが変更になり、いくつかのコマンドが追加されました。
・ドキュメントが変更になり、サンプルのコマンドの説明と第1版との違いが追
加されました。

次に内部的な変更点です。
これらの変更点についてはゲームプログラマは特に気にする必要はありません。

・EPIのアクセスパラメータ PGSが 0xd から 0xf に変更されました。
・各コマンド内部におけるステータスチェックが緩くなりました。
========================================================================
